/*	general
---------------------------------------------------------------------------------- */



//	string interpolation
`My string and ${ myVar } hand-in-hand.`







/*	terminology
---------------------------------------------------------------------------------- */



/*	sync vs async
------------------- */

synchronous = one by one in sequence, can only proceed after one finishes
asynchronous = non sequential; next in line can start before previous finishes







/*	promises
---------------------------------------------------------------------------------- */



/*	example
------------------- */

doSomeAsyncTask() {
	return new Promise( ( resolve, reject )=> {
		//	doYourAsyncTask
		if ( yourTasks suceeds ) {
			resolve( //	pass a string or object here optionally )
		} else {
			reject( //	pass a string or object here optionally )
		}
	})
}

doSomeAsyncTask()
.then( ( //	recieve object or string )=> {
	console.log( //	object or string )
})
.catch( ( //	recieve object or string )=> {
	console.log( //	object or string )
})







/*	math
---------------------------------------------------------------------------------- */



Math.floor
//	returns the largest integer less than or equal to a given number

Math.ceil
//	returns the smallest integer greater than or equal to a given number

Math.trunc
//	returns the integer part of a number by removing any fractional digits
//	shorthand ~~

Math.round
//	returns the value of a number rounded to the nearest integer







/*	helpers
---------------------------------------------------------------------------------- */



/*	what is
------------------- */



function isArray( object ) {
	return Object.prototype.toString.call( object ) == '[object Array]';
}

function isFunction( object ) {
	return typeof object == 'function';
}

function isNumber( object ) {
	return typeof object == 'number';
}

function isString( object ) {
	return typeof object == 'string';
}



/*	random
------------------- */



//	to update
function random( min, max ) {
	if ( isArray( min ) && min.length === 2 ) {
		return min[ 0 ] + Math.random() * ( min[ 1 ] - min[ 0 ] )
	}
	if ( isArray( min ) ) {
		return min[ ~~( Math.random() * min.length ) ]
	}
	if ( !isNumber( max ) ) {
		max = min || 1, min = 0
	}
	return min + Math.random() * ( max - min )
}



//	shuffle arrays
function shuffle( arr ) {
	let i = arr.length, t, r
	while ( 0 !== i ) {
		r = Math.floor( Math.random() * i )
		i -= 1
		t = arr[ i ]
		arr[ i ] = arr[ r ]
		arr[ r ] = t
	}
	return arr;
}



// const oneTimeFunction = once( function() {
// 	// function goes here
// });
// creates function that only runs once
function once( fn, context ) {
	let result;
	return function() {
		if( fn ) {
			result = fn.apply( context || this, arguments );
			fn = null;
		}
		return result;
	};
}



// const myFunction = debounce( function() {
// 	// stuff I want to do
// }, 500);
// window.addEventListener( 'resize', myFunction );
// function waits or immediately activates only after x is done
function debounce( func, wait, immediate ) {
	let timeout;
	return function() {
		let context = this, args = arguments;
		let later = function() {
			timeout = null;
			if ( !immediate ) func.apply( context, args );
		};
		let callNow = immediate && !timeout;
		clearTimeout( timeout );
		timeout = setTimeout( later, wait );
		if ( callNow ) func.apply( context, args );
	};
};






