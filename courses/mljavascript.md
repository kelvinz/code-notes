


<https://www.udemy.com/machine-learning-with-javascript/>



# what is machine learning



## problem solving process

1.	identify the independent & dependent variables
	*features* - are categories of data points that affect the value of a label

2.	assemble a set of data related to the problem you're trying to solve
	datasets almost always require cleanup or formatting

3.	decide on the type of output you are predicting
	*classification* - labels belong to a discret set
	*regression* - labels belong to a continuous set

4.	based on type of output,
	pick an algorithm that will determine a correlation between your 'feature' & 'labels'
	many algorithms exist, each with pros & cons

5.	use model generated by algorithm to make a prediction
	models relate the value of 'features' to the value of 'labels'



---



# algorithm overview



## k-nearest neighbor ( knn )

one of the simplest machine learning algorithms
essentially averaging the most similar inputs previously & their results

*eg. which bucket will a ball go into if dropped at 300px*

-	drop a ball a bunch of times all around the board
-	for each observation, subtract drop point from 300px to get absolute value
-	sort the results from least to most
-	look at the 'k' top records, what was the most frequent bucket
-	the more frequent bucket is our prediction

*note: k is a generic number which can be experimented & adjusted to suit different tasks*



## lodash

javascript utility library

```js

	const numbers = [
		[ 10, 5 ],
		[ 17, 2 ],
		[ 34, 1 ]
	]

	const sorted = _.sortBy( numbers, row => row[ 1 ] )

	//	results in
	sorted = [
		[ 34, 1 ],
		[ 17, 2 ],
		[ 10, 5 ]
	]

	const mapped = _.map( sorted, row => row[ 1 ] )

	//	results in
	mapped = [ 1, 2, 5 ]

	//	chaining
	//	_.chain to start chain
	//	.value() to get result
	const chained = _.chain( numbers )
						.sortBy( row => row[ 1 ] )
						.map( row => row[ 1 ] )
						.value();

```



## implementing knn

```js

	const outputs = [
		//	drop position, bounciness, ball size, result
		[ 10, .5, 16, 1 ],
		[ 200, .5, 16, 4 ],
		[ 350, .5, 16, 4 ],
		[ 600, .5, 16, 5 ]
	]

	const
	predictionPoint = 300,
	k = 3

	function distance( point, predictionPoint ) {
		return Math.abs( point - predictionPoint )
	}

	//	using lodash
	_.chain( outputs )
		//	get abs difference & results into an array, ignoring bounce & size
		.map( row => [ distance( row[ 0 ], predictionPoint ), row[ 3 ] ] )
		//	sort difference from lowest to highest
		.sortBy( row => row[ 0 ] )
		//	get top k records
		.slice( 0, k )
		//	get object with value of row[ 1 ] & number of times it occurs
		//	countBy changes value/keys into strings
		//	note to change back to num later
		.countBy( row => row[ 1 ] )
		//	take object & convert to array of arrays
		.toPairs( )
		//	sort most commonly occurring bucket from low to high
		.sortBy( row => row[ 1 ] )
		//	return last element aka [ "4", "2" ]
		.last()
		//	return first element aka "4"
		.first()
		//	change to num
		.parseInt()
		.value();

```
---



# onwards to tensorflow js



---



# applications of tensorflow



---



# getting started with gradient descent



---



# gradient descent with tensorflow



---



# increasing performance with vectorized solutions



---



# plotting data with javascript



---



# gradient descent alterations



---



# natural binary classification



---
